{
	"py_dict": {
		"prefix": "py_dict",
		"body": [
			"my_dict = {",
			"  \"my_key\": \"my_value\"",
			"\t}"
		]
	},
	"py_lambda": {
		"prefix": "py_lambda",
		"body": [
			"lambda x: x ** 2"
		]
	},
	"py_open_file": {
		"prefix": "py_open_file",
		"body": [
			"with open('myfile.txt') as file:",
			"  data = file.read()"
		]
	},
	"py_func": {
		"prefix": "py_func",
		"body": [
			"def foo(arg1):",
			"  # CODEHERE"
		]
	},
	"py_write_file": {
		"prefix": "py_write_file",
		"body": [
			"with open('myfile.txt', 'w') as file:",
			"  file.write('Hi there!')"
		]
	},
	"py_list_comp": {
		"prefix": "py_list_comp",
		"body": [
			"[x * 2 for x in mylist if x > 2]"
		]
	},
	"py_main": {
		"prefix": "py_main",
		"body": [
			"if __name__ == '__main__':",
			"  print('CODE')"
		]
	},
	"py_shebang": {
		"prefix": "py_shebang",
		"body": [
			"#!/usr/bin/python3"
		]
	},
	"py_subprocess": {
		"prefix": "py_subprocess",
		"body": [
			"output = subprocess.check_output(['mycmd', 'myarg'], universal_newlines=True)"
		]
	},
	"py_filter": {
		"prefix": "py_filter",
		"body": [
			"filter(lambda i: i < 5, mylist)"
		]
	},
	"py_map": {
		"prefix": "py_map",
		"body": [
			"map(lambda: x: x * 2, mylist)"
		]
	},

	"import_datasci": {
		"prefix": "import_datasci",
		"body": [
			"import numpy as np",
			"import pandas as pd",
			"import matplotlib as plt",
			"import seaborn as sns",
			"",
			"%matplotlib inline"
		]
	},
	"pandas_csv": {
		"prefix": "pandas_csv",
		"body": [
			"df = pd.read_csv('my_csv.csv')"
		]
	},
	"pandas_info": {
		"prefix": "pandas_info",
		"body": [
			"df.head()",
			"df.info()",
			"df.dtypes"
		]
	},
	"pandas_sort": {
		"prefix": "pandas_sort",
		"body": [
			"df.sort_values(by = 'foo')"
		]
	},
	"pandas_group": {
		"prefix": "pandas_group",
		"body": [
			"df_counted = df.groupby(['col1', 'col2']).count()"
		]
	},
	"pandas_apply": {
		"prefix": "pandas_apply",
		"body": [
			"df['sqrt_values'] = df['values'].apply(np.sqrt)"
		]
	},
	"sklearn_linear": {
		"prefix": "sklearn_linear",
		"body": [
			"from sklearn.linear_model import LinearRegression"
		]
	},
	"sklearn_logistic": {
		"prefix": "sklearn_logistic",
		"body": [
			"from sklearn.linear_model import LogisticRegression"
		]
	},
	"sklearn_model": {
		"prefix": "sklearn_model",
		"body": [
			"model = LinearRegression(normalize = True)"
		]
	},
	"sklearn_train_test_split": {
		"prefix": "sklearn_train_test_split",
		"body": [
			"# Where `X` is the data df and `y` is the labels df/series.",
			"from sklearn.model_selection import train_test_split #previously from sklearn.cross_validation",
			"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)"
		]
	},
	"sklearn_fit": {
		"prefix": "sklearn_fit",
		"body": [
			"model.fit(X_train, y_train)"
		]
	},
	"sklearn_predict": {
		"prefix": "sklearn_predict",
		"body": [
			"predictions = model.predict(X_test)"
		]
	},
	"sklearn_errors": {
		"prefix": "sklearn_errors",
		"body": [
			"from sklearn import metrics",
			"",
			"metrics.mean_absolute_error(y_test, predictions)",
			"metrics.mean_squared_error(y_test, predictions)",
			"np.sqrt(metrics.mean_squared_error(y_test, predictions))"
		]
	},
	"sklearn_classification": {
		"prefix": "sklearn_classification",
		"body": [
			"from sklearn.metrics import classification_report",
			"print(classification_report(y_test,predictions))"
		]
	},
	"sklearn_confusion": {
		"prefix": "sklearn_classification",
		"body": [
			"from sklearn.metrics import confusion_matrix",
			"print(confusion_matrix(y_true, y_pred))"
		]
	}
}