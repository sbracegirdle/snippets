{
	"py_if": {
		"prefix": [
			"py_if",
			"if"
		],
		"body": [
			"if ${1:condition}:",
			"  $0"
		]
	},
	"py_for": {
		"prefix": [
			"py_for_in",
			"forin",
			"for_in"
		],
		"body": [
			"for ${2:item} in ${1:iterable}:",
			"  $0"
		]
	},
	"py_dict": {
		"prefix": [
			"py_dict",
			"dict"
		],
		"body": [
			"my_dict = {",
			"  \"$1\": \"$2\"",
			"  $0",
			"}"
		]
	},
	"py_lambda": {
		"prefix": [
			"py_lambda",
			"lamb",
			"lambda"
		],
		"body": [
			"lambda x: $0"
		]
	},
	"py_open_file": {
		"prefix": [
			"py_open_file",
			"open_file",
			"read",
			"open"
		],
		"body": [
			"with open($1) as file:",
			"  data = file.read()$0"
		]
	},
	"py_func": {
		"prefix": [
			"py_func",
			"def",
			"fun",
			"func"
		],
		"body": [
			"def $1($2):",
			"  $0"
		]
	},
	"py_write_file": {
		"prefix": [
			"py_write_file",
			"write",
			"write_file"
		],
		"body": [
			"with open($1, 'w') as file:",
			"  file.write('Hi there!')$0"
		]
	},
	"py_list_comp": {
		"prefix": [
			"py_list_comp",
			"list_comp",
			"listcomp",
			"comp"
		],
		"body": [
			"[x * 2 for x in mylist if x > 2]"
		]
	},
	"py_main": {
		"prefix": [
			"py_main",
			"main"
		],
		"body": [
			"if __name__ == '__main__':",
			"  $0"
		]
	},
	"py_shebang": {
		"prefix": [
			"py_shebang",
			"shebang"
		],
		"body": [
			"#!/usr/bin/python3"
		]
	},
	"py_subprocess": {
		"description": "Call a sub process and capture the output in a string",
		"prefix": [
			"py_subprocess",
			"checkoutput",
			"subprocess"
		],
		"body": [
			"import subprocess",
			"output = subprocess.check_output(['mycmd', 'myarg'])"
		]
	},
	"py_subprocess_try": {
		"description": "subprocess.check_output with catch for process error",
		"prefix": [
			"py_subprocess_try",
			"py_subprocess_try_catch"
		],
		"body": [
			"try:",
			"\toutput = subprocess.check_output(RUN_SCRAPER, stderr=subprocess.STDOUT)",
			"except subprocess.CalledProcessError as e:",
			"\tprint(e.output)"
		]
	},
	"py_bg_process": {
		"prefix": [
			"py_bg_process",
			"bg_process",
			"background"
		],
		"body": [
			"import subprocess",
			"ls_output = subprocess.Popen(['${1:sleep}', '30'])",
			"# Dont run this if you want it to be non-blocking (background) ",
			"# ls_output.communicate()  # Will block for 30 seconds"
		]
	},
	"py_filter": {
		"prefix": [
			"py_filter",
			"filter"
		],
		"body": [
			"filter(${1:lambda i: i < 5}, ${2:mylist})"
		]
	},
	"py_map": {
		"prefix": [
			"py_map",
			"map"
		],
		"body": [
			"map(${1:lambda: x: x * 2}, ${2:mylist})"
		]
	},
	"py_list_push": {
		"prefix": [
			"py_list_push",
			"push",
			"append"
		],
		"body": [
			".append('item')"
		]
	},
	"py_list_find": {
		"prefix": [
			"py_list_find",
			"find",
			"index"
		],
		"body": [
			".index(myval)"
		]
	},
	"py_reduce": {
		"prefix": [
			"py_reduce",
			"reduce"
		],
		"body": [
			"from functools import reduce",
			"reduce(lambda accum, item: accum * item, mylist, 4)"
		]
	},
	"py_str_to_int": {
		"prefix": [
			"py_str_to_int"
		],
		"body": [
			"int(${1:str})"
		]
	},
	"import_psycopg": {
		"prefix": [
			"import_psycopg",
			"psycopg_import"
		],
		"body": [
			"import psycopg2"
		]
	},
	"psycopg_connect": {
		"prefix": [
			"psycopg_connect",
			"connect"
		],
		"body": [
			"with psycopg2.connect(dbname='db', user='user', password='pass', host='host', port=5432, connect_timeout=3) as conn:",
			"  $0"
		]
	},
	"psycopg_query": {
		"prefix": [
			"psycopg_query",
			"query",
			"fetchall",
			"psycopg_fetchall",
			"psycopg_fetch"
		],
		"body": [
			"with conn.cursor() as curs:",
			"  curs.execute(${1:'sql'})",
			"  data = curs.fetchall()"
		]
	},
	"import_datasci": {
		"prefix": "import_datasci",
		"body": [
			"import numpy as np",
			"import pandas as pd",
			"import matplotlib.pyplot as plt",
			"import seaborn as sns",
			"",
			"%matplotlib inline"
		]
	},
	"pandas_pivot": {
		"prefix": [
			"pandas_pivot"
		],
		"body": [
			"df.pivot_table(values='passenger', index='month', 'columns='year', aggfunc=len)"
		]
	},
	"pandas_dataframe": {
		"prefix": [
			"pandas_dataframe",
			"dataframe"
		],
		"body": [
			"df = pd.DataFrame(data={'col1': [1, 2], 'col2': [3, 4]})"
		]
	},
	"pandas_dataframe_numpy": {
		"prefix": [
			"pandas_dataframe_numpy",
			"dataframe_numpy",
			"dataframe_array"
		],
		"body": [
			"df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),",
			"\tcolumns=['a', 'b', 'c'])"
		]
	},
	"pandas_json": {
		"prefix": "pandas_json",
		"body": [
			"df = pd.read_json('my_json.json')"
		]
	},
	"pandas_csv": {
		"prefix": "pandas_csv",
		"body": [
			"df = pd.read_csv('my_csv.csv')"
		]
	},
	"pandas_info": {
		"prefix": "pandas_info",
		"body": [
			"df.head()",
			"df.info()",
			"df.dtypes"
		]
	},
	"pandas_sort": {
		"prefix": "pandas_sort",
		"body": [
			"df.sort_values(by='foo')"
		]
	},
	"pandas_group": {
		"prefix": "pandas_group",
		"body": [
			"df_counted = df.groupby(['col1', 'col2']).count()"
		]
	},
	"pandas_apply": {
		"prefix": "pandas_apply",
		"body": [
			"df['sqrt_values'] = df['values'].apply(np.sqrt)"
		]
	},
	"sns_iris": {
		"prefix": [
			"data_iris",
			"sns_iris",
			"seaborn_iris"
		],
		"body": [
			"iris = sns.load_dataset('iris')"
		]
	},
	"sns_pairgrid": {
		"prefix": [
			"pairgrid",
			"sns_pairgrid",
			"seaborn_pairgrid",
			"pairgrid",
			"sns_grid",
			"seaborn_grid"
		],
		"body": [
			"g = sns.PairGrid(df)",
			"g.map(plt.scatter)"
		]
	},
	"sns_pairplot": {
		"prefix": [
			"pairplot",
			"sns_pairplot",
			"seaborn_pairplot"
		],
		"body": [
			"sns.pairplot(df)"
		]
	},
	"sns_bar": {
		"prefix": [
			"barplot",
			"sns_bar",
			"sns_barplot",
			"seaborn_bar",
			"seaborn_barplot"
		],
		"body": [
			"sns.barplot(x='sex', y='survived', hue='class', data=df)"
		]
	},
	"sns_countplot": {
		"prefix": [
			"countplot",
			"sns_countplot",
			"seaborn_countplot"
		],
		"body": [
			"sns.countplot(x='sex', data=df)"
		]
	},
	"sns_dist": {
		"prefix": [
			"dist",
			"distribution",
			"sns_dist",
			"seaborn_dist",
			"sns_distribution",
			"seaborn_distribution"
		],
		"body": [
			"sns.distplot(df['bill'])"
		]
	},
	"sns_lineplot": {
		"prefix": [
			"sns_lineplot",
			"lineplot",
			"seaborn_lineplot"
		],
		"body": [
			"sns.lineplot(x='timepoint', y='signal', data=df)"
		]
	},
	"sns_heatmap": {
		"prefix": [
			"sns_heatmap",
			"heatmap",
			"seaborn_heatmap"
		],
		"body": [
			"sns.heatmap(df)"
		]
	},
	"sns_regression": {
		"prefix": [
			"sns_regression",
			"regression_plot",
			"seaborn_regression"
		],
		"body": [
			"sns.regplot(x='timepoint', y='signal', data=df)"
		]
	},
	"sklearn_linear": {
		"prefix": "sklearn_linear",
		"body": [
			"from sklearn.linear_model import LinearRegression"
		]
	},
	"sklearn_logistic": {
		"prefix": "sklearn_logistic",
		"body": [
			"from sklearn.linear_model import LogisticRegression"
		]
	},
	"sklearn_model": {
		"prefix": "sklearn_model",
		"body": [
			"model = LinearRegression(normalize = True)"
		]
	},
	"sklearn_train_test_split": {
		"prefix": "sklearn_train_test_split",
		"body": [
			"# Where `X` is the data df and `y` is the labels df/series.",
			"from sklearn.model_selection import train_test_split #previously from sklearn.cross_validation",
			"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)"
		]
	},
	"sklearn_fit": {
		"prefix": "sklearn_fit",
		"body": [
			"model.fit(X_train, y_train)"
		]
	},
	"sklearn_predict": {
		"prefix": "sklearn_predict",
		"body": [
			"predictions = model.predict(X_test)"
		]
	},
	"sklearn_metrics": {
		"prefix": "sklearn_metrics",
		"body": [
			"from sklearn import metrics",
			"",
			"metrics.mean_absolute_error(y_test, predictions)",
			"metrics.mean_squared_error(y_test, predictions)",
			"np.sqrt(metrics.mean_squared_error(y_test, predictions))"
		]
	},
	"sklearn_classification": {
		"prefix": "sklearn_classification",
		"body": [
			"from sklearn.metrics import classification_report",
			"print(classification_report(y_test,predictions))"
		]
	},
	"sklearn_confusion": {
		"prefix": "sklearn_confusion",
		"body": [
			"from sklearn.metrics import confusion_matrix",
			"print(confusion_matrix(y_true, y_pred))"
		]
	},
	"import_torch": {
		"prefix": [
			"import_torch",
			"import_pytorch",
			"i_torch"
		],
		"body": [
			"import torch"
		]
	},
	"torch_share": {
		"prefix": "torch_share",
		"body": [
			"torch.from_numpy(${1:np.array([1,2,3])})"
		]
	},
	"torch_tensor": {
		"prefix": [
			"torch_tensor",
			"tensor",
			"torch_copy"
		],
		"body": [
			"torch.tensor(${1:np.array([1,2,3])})"
		]
	},
	"torch_empty": {
		"prefix": "torch_empty",
		"body": [
			"torch.empty(${1:4}, ${2:3})"
		]
	},
	"torch_rand": {
		"prefix": "torch_rand",
		"body": [
			"torch.rand(${1:4}, ${2:3})"
		]
	},
	"torch_shape": {
		"prefix": [
			"torch_shape",
			"shape"
		],
		"body": [
			"${1:x}.shape"
		]
	},
	"torch_reshape": {
		"prefix": [
			"torch_reshape",
			"reshape",
			"view"
		],
		"body": [
			"${1:x}.reshape(${2:rows}, ${3:cols})"
		]
	},
	"torch_get": {
		"prefix": [
			"torch_get"
		],
		"body": [
			"${1:x}[${2:row},${3:col}]"
		]
	},
	"cdk_usage_comment": {
		"prefix": [
			"cdk_usage_comment",
			"cdk",
			"cdk_usage",
			"cdk_help",
			"aws_help"
		],
		"body": [
			"# CDK INSTALL: ",
			"#   npm install -g aws-cdk ",
			"#",
			"# CDK CLI: ",
			"#   cdk init ",
			"#   cdk deploy ",
			"#   cdk destroy ",
			"#",
			"# CDK requirements.txt: ",
			"#   aws-cdk.aws-events",
			"#   aws-cdk.aws-events-targets",
			"#   aws-cdk.aws-lambda",
			"#   aws-cdk.core"
		]
	},
	"cdk_import": {
		"prefix": [
			"cdk_import"
		],
		"body": [
			"from aws_cdk import (",
			"  core,",
			"  aws_lambda as _lambda,",
			"  aws_apigateway as _apigw,",
			"  aws_s3 as _s3",
			")"
		]
	},
	"cdk_app": {
		"prefix": [
			"cdk_app"
		],
		"body": [
			"app = core.App()",
			"ApiCorsLambdaStack(app, \"${1:MyStack}\")",
			"app.synth()"
		]
	},
	"cdk_stack": {
		"prefix": [
			"cdk_stack"
		],
		"body": [
			"class ${1:MyStack}(core.Stack): ",
			"  def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:",
			"    super().__init__(scope, id, **kwargs)",
			"    $0"
		]
	},
	"cdk_lambda": {
		"prefix": [
			"cdk_lambda"
		],
		"body": [
			"lambdaFn = lambda_.Function(",
			"  self,",
			"  'Singleton',",
			"  code=lambda_.InlineCode(handler_code),",
			"  handler='index.main',",
			"  timeout=core.Duration.seconds(300),",
			"  runtime=lambda_.Runtime.PYTHON_3_7,",
			")"
		]
	},
	"cdk_cron": {
		"prefix": [
			"cdk_cron"
		],
		"body": [
			"rule = events.Rule(",
			"  self,",
			"  'Rule',",
			"  schedule=events.Schedule.cron(",
			"    year='*',",
			"    month='*',",
			"    week_day='MON-FRI',",
			"    hour='18',",
			"    minute='0'",
			"  ),",
			")",
			"rule.add_target(targets.LambdaFunction(lambdaFn))",
		]
	},
	"cdk_s3": {
		"prefix": [
			"cdk_s3",
			"bucket",
			"cdk_bucket"
		],
		"body": [
			"s3 = _s3.Bucket(self, 's3bucket')"
		]
	},
	"autopep8": {
		"description": "Add comments to assist in installing pep8 and running pep8",
		"prefix": [
			"autopep8",
			"pep8",
			"autopep8_help",
			"autopep8_comment",
			"pep8_help",
			"pep8_comment"
		],
		"body": [
			"# pip install --upgrade autopep8",
			"# autopep8 --in-place --aggressive --aggressive <filename>"
		]
	},
	"args": {
		"prefix": [
			"args",
			"py_args",
			"cli_args"
		],
		"body": [
			"import sys",
			"print('This is the name of the script: ', sys.argv[0])",
			"print('Number of arguments: ', len(sys.argv))",
			"print('The arguments are: ' , str(sys.argv))",
		]
	},
	"dir_files": {
		"prefix": [
			"dir_files",
			"listdir",
			"list_dir",
			"dirfiles"
		],
		"body": [
			"from os import listdir",
			"from os.path import isfile, join",
			"onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]"
		]
	},
	"jupyter_cell": {
		"prefix": [
			"jupyter_cell",
			"cell"
		],
		"body": [
			"#%%"
		]
	},
}