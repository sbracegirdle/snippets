{
	"py_if": {
		"prefix": [
			"py_if",
			"if"
		],
		"body": [
			"if ${1:condition}:",
			"  $0"
		]
	},
	"py_for": {
		"prefix": [
			"py_for_in",
			"forin",
			"for_in"
		],
		"body": [
			"for ${2:item} in ${1:iterable}:",
			"  $0"
		]
	},
	"py_dict": {
		"prefix": [
			"py_dict",
			"dict"
		],
		"body": [
			"my_dict = {",
			"  \"$1\": \"$2\"",
			"  $0",
			"}"
		]
	},
	"py_lambda": {
		"prefix": [
			"py_lambda",
			"lamb",
			"lambda"
		],
		"body": [
			"lambda x: $0"
		]
	},
	"py_open_file": {
		"prefix": [
			"py_open_file",
			"open_file",
			"read",
			"open"
		],
		"body": [
			"with open($1) as file:",
			"  data = file.read()$0"
		]
	},
	"py_func": {
		"prefix": [
			"py_func",
			"def",
			"fun",
			"func"
		],
		"body": [
			"def $1($2):",
			"  $0"
		]
	},
	"py_write_file": {
		"prefix": [
			"py_write_file",
			"write",
			"write_file"
		],
		"body": [
			"with open($1, 'w') as file:",
			"  file.write('Hi there!')$0"
		]
	},
	"py_list_comp": {
		"prefix": [
			"py_list_comp",
			"list_comp",
			"listcomp",
			"comp"
		],
		"body": [
			"[x * 2 for x in mylist if x > 2]"
		]
	},
	"py_main": {
		"prefix": [
			"py_main",
			"main"
		],
		"body": [
			"if __name__ == '__main__':",
			"  $0"
		]
	},
	"py_shebang": {
		"prefix": [
			"py_shebang",
			"shebang"
		],
		"body": [
			"#!/usr/bin/python3"
		]
	},
	"py_subprocess": {
		"prefix": [
			"py_subprocess",
			"checkoutput",
			"subprocess"
		],
		"body": [
			"output = subprocess.check_output(['mycmd', 'myarg'], universal_newlines=True)"
		]
	},
	"py_filter": {
		"prefix": [
			"py_filter",
			"filter"
		],
		"body": [
			"filter(${1:lambda i: i < 5}, ${2:mylist})"
		]
	},
	"py_map": {
		"prefix": [
			"py_map",
			"map"
		],
		"body": [
			"map(${1:lambda: x: x * 2}, ${2:mylist})"
		]
	},
	"py_list_push": {
		"prefix": [
			"py_list_push",
			"push",
			"append"
		],
		"body": [
			".append('item')"
		]
	},
	"py_list_find": {
		"prefix": [
			"py_list_find",
			"find",
			"index"
		],
		"body": [
			".index(myval)"
		]
	},
	"py_reduce": {
		"prefix": [
			"py_reduce",
			"reduce"
		],
		"body": [
			"from functools import reduce",
			"reduce(lambda accum, item: accum * item, mylist, 4)"
		]
	},
	"py_str_to_int": {
		"prefix": [
			"py_str_to_int"
		],
		"body": [
			"int(${1:str})"
		]
	},

	"import_psycopg": {
		"prefix": ["import_psycopg", "psycopg_import"],
		"body": [
			"import psycopg2"
		]
	},
	"psycopg_connect": {
		"prefix": ["psycopg_connect", "connect"],
		"body": [
			"with psycopg2.connect(dbname='db', user='user', password='pass', host='host', port=5432, connect_timeout=3) as conn:",
			"  $0"
		]
	},
	"psycopg_query": {
		"prefix": ["psycopg_query", "query", "fetchall", "psycopg_fetchall", "psycopg_fetch"],
		"body": [
			"with conn.cursor() as curs:",
			"  curs.execute(${1:'sql'})",
			"  data = curs.fetchall()"
		]
	},

	"import_datasci": {
		"prefix": "import_datasci",
		"body": [
			"import numpy as np",
			"import pandas as pd",
			"import matplotlib.pyplot as plt",
			"import seaborn as sns",
			"",
			"%matplotlib inline"
		]
	},
	"pandas_json": {
		"prefix": "pandas_json",
		"body": [
			"df = pd.read_json('my_json.json')"
		]
	},
	"pandas_csv": {
		"prefix": "pandas_csv",
		"body": [
			"df = pd.read_csv('my_csv.csv')"
		]
	},
	"pandas_info": {
		"prefix": "pandas_info",
		"body": [
			"df.head()",
			"df.info()",
			"df.dtypes"
		]
	},
	"pandas_sort": {
		"prefix": "pandas_sort",
		"body": [
			"df.sort_values(by = 'foo')"
		]
	},
	"pandas_group": {
		"prefix": "pandas_group",
		"body": [
			"df_counted = df.groupby(['col1', 'col2']).count()"
		]
	},
	"pandas_apply": {
		"prefix": "pandas_apply",
		"body": [
			"df['sqrt_values'] = df['values'].apply(np.sqrt)"
		]
	},
	"sklearn_linear": {
		"prefix": "sklearn_linear",
		"body": [
			"from sklearn.linear_model import LinearRegression"
		]
	},
	"sklearn_logistic": {
		"prefix": "sklearn_logistic",
		"body": [
			"from sklearn.linear_model import LogisticRegression"
		]
	},
	"sklearn_model": {
		"prefix": "sklearn_model",
		"body": [
			"model = LinearRegression(normalize = True)"
		]
	},
	"sklearn_train_test_split": {
		"prefix": "sklearn_train_test_split",
		"body": [
			"# Where `X` is the data df and `y` is the labels df/series.",
			"from sklearn.model_selection import train_test_split #previously from sklearn.cross_validation",
			"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)"
		]
	},
	"sklearn_fit": {
		"prefix": "sklearn_fit",
		"body": [
			"model.fit(X_train, y_train)"
		]
	},
	"sklearn_predict": {
		"prefix": "sklearn_predict",
		"body": [
			"predictions = model.predict(X_test)"
		]
	},
	"sklearn_metrics": {
		"prefix": "sklearn_metrics",
		"body": [
			"from sklearn import metrics",
			"",
			"metrics.mean_absolute_error(y_test, predictions)",
			"metrics.mean_squared_error(y_test, predictions)",
			"np.sqrt(metrics.mean_squared_error(y_test, predictions))"
		]
	},
	"sklearn_classification": {
		"prefix": "sklearn_classification",
		"body": [
			"from sklearn.metrics import classification_report",
			"print(classification_report(y_test,predictions))"
		]
	},
	"sklearn_confusion": {
		"prefix": "sklearn_confusion",
		"body": [
			"from sklearn.metrics import confusion_matrix",
			"print(confusion_matrix(y_true, y_pred))"
		]
	},
	"import_torch": {
		"prefix": [
			"import_torch",
			"import_pytorch",
			"i_torch"
		],
		"body": [
			"import torch"
		]
	},
	"torch_share": {
		"prefix": "torch_share",
		"body": [
			"torch.from_numpy(${1:np.array([1,2,3])})"
		]
	},
	"torch_tensor": {
		"prefix": [
			"torch_tensor",
			"tensor",
			"torch_copy"
		],
		"body": [
			"torch.tensor(${1:np.array([1,2,3])})"
		]
	},
	"torch_empty": {
		"prefix": "torch_empty",
		"body": [
			"torch.empty(${1:4}, ${2:3})"
		]
	},
	"torch_rand": {
		"prefix": "torch_rand",
		"body": [
			"torch.rand(${1:4}, ${2:3})"
		]
	},
	"torch_shape": {
		"prefix": [
			"torch_shape",
			"shape"
		],
		"body": [
			"${1:x}.shape"
		]
	},
	"torch_reshape": {
		"prefix": [
			"torch_reshape",
			"reshape",
			"view"
		],
		"body": [
			"${1:x}.reshape(${2:rows}, ${3:cols})"
		]
	},
	"torch_get": {
		"prefix": [
			"torch_get"
		],
		"body": [
			"${1:x}[${2:row},${3:col}]"
		]
	}
}